name: e2e-kind

on:
  workflow_run:
    workflows: ["Helm Chart"]   # имя workflow из docker.yml (name:)
    branches: [ main, develop ]            # где он запускается
    types: [completed]

concurrency:
  group: e2e-${{ github.event.workflow_run.head_sha || github.sha }}
  cancel-in-progress: true

permissions:
  contents: read
  packages: read

jobs:
  e2e-postgres:
    if: ${{ github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.event != 'pull_request' }}
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          ref: ${{ github.event.workflow_run.head_sha }}
          fetch-depth: 0

      - name: Debug refs
        run: |
          echo "repo:                 $GITHUB_REPOSITORY"
          echo "workflow file branch: $GITHUB_REF"
          echo "this job sha:         $GITHUB_SHA"
          echo "trigger head_sha:     ${{ github.event.workflow_run.head_sha }}"
          echo "trigger head_branch:  ${{ github.event.workflow_run.head_branch }}"

      - name: Setup Go
        uses: actions/setup-go@d35c59abb061a4a6fb18e82ac0862c26744d6ab5 # v5
        with:
          go-version: '1.24.x'
          check-latest: true

      - name: Create kind cluster
        uses: helm/kind-action@a1b0e391336a6ee6713a0583f8c6240d70863de3 # v1.12.0
        with:
          cluster_name: mcp-e2e

      - name: Export kubeconfig & sanity check
        id: kube
        run: |
          kind get kubeconfig --name mcp-e2e > /tmp/kubeconfig
          echo "KUBECONFIG=/tmp/kubeconfig" >> $GITHUB_ENV
          kubectl config current-context
          kubectl get nodes -o wide

      - name: Ensure namespace mcp exists
        run: kubectl create namespace mcp || true

      - name: Create GitHub token Secret
        env:
          MCP_GH_TOKEN: ${{ secrets.MCP_GH_TOKEN }}
        run: |
          set -e
          if [ -z "$MCP_GH_TOKEN" ]; then
            echo "::warning::MCP_GH_TOKEN is empty; proceeding without token (rate limit may be low)"
            exit 0
          fi
          # создаём/обновляем секрет БЕЗ печати токена в логи
          kubectl -n mcp create secret generic mcp-gh-token \
            --from-literal=token="$MCP_GH_TOKEN" \
            --dry-run=client -o yaml | kubectl apply -f - >/dev/null
          echo "Secret mcp-gh-token applied"

      - name: Assert chart CRDs layout (crds/ only)
        run: |
          set -e

          # 0) Папка crds/ должна существовать
          test -d helm/mcp-operator/crds || { echo "::error::helm/mcp-operator/crds not found"; exit 1; }

          # 1) В crds/ должно быть ровно 3 CRD (подсчёт по файлам)
          CRD_CNT=$(grep -R "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" -n helm/mcp-operator/crds | wc -l || true)
          if [ "$CRD_CNT" -ne 3 ]; then
            echo "::error::Expected 3 CRDs in helm/mcp-operator/crds, got $CRD_CNT"
            grep -R "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" -n helm/mcp-operator/crds || true
            exit 1
          fi

          # 2) В templates/ не должно быть CRD
          if grep -R "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" -n helm/mcp-operator/templates >/dev/null 2>&1; then
            echo "::error::CRD manifests must NOT be in helm/mcp-operator/templates (move them to crds/)"
            grep -R "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" -n helm/mcp-operator/templates || true
            exit 1
          fi

          # 3) helm template должен показывать CRD ТОЛЬКО с флагом --include-crds
          REN_CNT=$(helm template ./helm/mcp-operator --include-crds | grep -c "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" || true)
          if [ "$REN_CNT" -ne 3 ]; then
            echo "::error::helm template --include-crds should render 3 CRDs, got $REN_CNT"
            helm template ./helm/mcp-operator --include-crds | awk '/^kind:[[:space:]]*CustomResourceDefinition/{p=1} p&&/name:/{print $2; p=0}'
            exit 1
          fi

          # (доп) альтернативная проверка через helm show crds
          SHOW_CNT=$(helm show crds ./helm/mcp-operator | grep -c "^[[:space:]]*kind:[[:space:]]*CustomResourceDefinition" || true)
          if [ "$SHOW_CNT" -ne 3 ]; then
            echo "::error::helm show crds should list 3 CRDs, got $SHOW_CNT"
            helm show crds ./helm/mcp-operator || true
            exit 1
          fi

      - name: Ensure controller-gen installed
        run: go install sigs.k8s.io/controller-tools/cmd/controller-gen@v0.16.4

      - name: Verify CRDs are in sync with chart
        run: make check-crds


      - name: Install MCP Operator (Helm)
        run: |
          set -e
          IMAGE_NAME="$(echo '${{ github.repository }}' | tr '[:upper:]' '[:lower:]')"
          OP_TAG="sha-${{ github.event.workflow_run.head_sha }}"
          OP_REPO="ghcr.io/${IMAGE_NAME}"

          # 1) ставим чарт в ns mcp
          if [ -d ./helm/mcp-operator ]; then
            helm upgrade --install mcp-operator ./helm/mcp-operator \
              --namespace mcp --create-namespace \
              --set registry.enabled=true \
              --set registry.auth.secretName=mcp-gh-token \
              --set registry.source.type=github \
              --set registry.source.repo=docker/mcp-registry \
              --set registry.source.branch=main \
              --set registry.source.path=servers
          else
            helm repo add mcp-operator https://fantasynitrogen.github.io/mcp_operator/
            helm repo update
            helm upgrade --install mcp-operator mcp-operator/mcp-operator \
              --namespace mcp --create-namespace \
              --set registry.enabled=true \
              --set registry.auth.secretName=mcp-gh-token \
              --set registry.source.type=github \
              --set registry.source.repo=docker/mcp-registry \
              --set registry.source.branch=main \
              --set registry.source.path=servers
          fi

          # выставляем нужный образ по SHA и ждём раскатку
          CTN="$(kubectl -n mcp get deploy mcp-operator -o jsonpath='{.spec.template.spec.containers[0].name}')"
          OP_IMG="${OP_REPO}:${OP_TAG}"
          kubectl -n mcp set image deploy/mcp-operator "${CTN}=${OP_IMG}" --record
          kubectl -n mcp rollout status deploy/mcp-operator --timeout=300s

      - name: MCPRegistry spec is github source (no url)
        run: |
          set -e
          echo "Rendered MCPRegistry.spec:"
          kubectl -n mcp get mcpregistry default-registry -o json | jq '.spec'

          URL="$(kubectl -n mcp get mcpregistry default-registry -o jsonpath='{.spec.url}' 2>/dev/null || true)"
          if [ -n "$URL" ]; then
            echo "::error::.spec.url is set but controller supports only source.github; got: $URL"
            exit 1
          fi

          REPO="$(kubectl -n mcp get mcpregistry default-registry -o jsonpath='{.spec.source.github.repo}' 2>/dev/null || true)"
          if [ "$REPO" != "docker/mcp-registry" ]; then
            echo "::error::.spec.source.github.repo unexpected: '$REPO'"
            echo "Got: '${REPO:-<empty>}' ; Want: 'docker/mcp-registry'"
            exit 1
          fi

          BRANCH="$(kubectl -n mcp get mcpregistry default-registry -o jsonpath='{.spec.source.github.branch}' 2>/dev/null || true)"
          echo "Branch: ${BRANCH:-<empty>} (ok if 'main')"

      - name: operator health & CRDs
        run: |
          set -e
          kubectl -n mcp get deploy mcp-operator -o wide
          echo "Known CRDs under mcp.allbeone.io:"
          kubectl get crd | grep 'mcp\.allbeone\.io' || true
          echo "--- recent events ---"
          kubectl -n mcp get events --sort-by=.lastTimestamp | tail -n 50 || true

      - name: Verify operator and webhooks are installed and working
        run: |
          set -e
          echo "=== Проверка CRD ==="
          echo "CRDs with mcp domain:"
          kubectl get crd | grep mcp || { echo "::error::No MCP CRDs found"; exit 1; }

          EXPECTED_CRDS="mcpservers.mcp.allbeone.io mcpserverbackups.mcp.allbeone.io mcpregistries.mcp.allbeone.io"
          for crd in $EXPECTED_CRDS; do
            kubectl get crd "$crd" >/dev/null 2>&1 || { echo "::error::Required CRD not found: $crd"; exit 1; }
            echo "✓ CRD found: $crd"
          done

          echo "=== Проверка подов оператора ==="
          OPERATOR_PODS=$(kubectl -n mcp get pods | grep mcp-operator || true)
          if [ -z "$OPERATOR_PODS" ]; then
            echo "::error::No MCP operator pods found in ns mcp"
            kubectl -n mcp get pods || true
            exit 1
          fi
          echo "$OPERATOR_PODS"

          OPERATOR_POD_NAME=$(kubectl -n mcp get pods -l control-plane=controller-manager -o jsonpath='{.items[0].metadata.name}' 2>/dev/null || true)
          if [ -z "$OPERATOR_POD_NAME" ]; then
            OPERATOR_POD_NAME=$(kubectl -n mcp get pods | awk '/mcp-operator/{print $1; exit}' || true)
          fi

          if [ -z "$OPERATOR_POD_NAME" ]; then
            echo "::error::Could not find operator pod name"
            kubectl -n mcp get pods
            exit 1
          fi

          echo "Checking operator pod readiness: $OPERATOR_POD_NAME"
          READY_STATUS=$(kubectl -n mcp get pod "$OPERATOR_POD_NAME" -o jsonpath='{.status.containerStatuses[0].ready}' 2>/dev/null || echo "false")
          if [ "$READY_STATUS" != "true" ]; then
            echo "::error::Operator pod is not ready: $OPERATOR_POD_NAME"
            kubectl -n mcp describe pod "$OPERATOR_POD_NAME" || true
            exit 1
          fi
          echo "✓ Operator pod is ready"

          echo "=== Проверка вебхуков (условно) ==="
          # считаем вебхуки включёнными, если есть хоть один ресурс или сервис вебхуков
          HAS_VWC=$(kubectl get validatingwebhookconfigurations 2>/dev/null | grep -i mcp || true)
          HAS_MWC=$(kubectl get mutatingwebhookconfigurations 2>/dev/null | grep -i mcp || true)
          HAS_SVC=$(kubectl -n mcp get svc 2>/dev/null | grep -i webhook || true)

          if [ -n "$HAS_VWC$HAS_MWC$HAS_SVC" ]; then
            echo "Webhooks detected, validating presence…"
            if [ -z "$HAS_VWC" ]; then
              echo "::error::ValidatingWebhookConfiguration expected but not found"
              kubectl get validatingwebhookconfigurations || true
              exit 1
            fi
            if [ -z "$HAS_MWC" ]; then
              echo "::error::MutatingWebhookConfiguration expected but not found"
              kubectl get mutatingwebhookconfigurations || true
              exit 1
            fi
            echo "✓ Webhook configurations present"
            echo "=== Проверка логов оператора на ошибки вебхука ==="
            WEBHOOK_ERRORS=$(kubectl -n mcp logs "$OPERATOR_POD_NAME" --since=5m | grep -i -E "(webhook.*server.*error|webhook.*port.*error|failed.*webhook|webhook.*failed)" || true)
            if [ -n "$WEBHOOK_ERRORS" ]; then
              echo "::error::Webhook server errors found in logs:"
              echo "$WEBHOOK_ERRORS"
              exit 1
            fi
            echo "✓ No webhook server errors found in logs"
          else
            echo "::notice::MCP admission webhooks are not installed in this chart/config — skipping webhook checks."
          fi

          echo "=== Критерий готовности: ✓ PASSED (без обязательных вебхуков) ==="

      - name: operator RBAC for core
        run: |
          set -e
          echo "configmaps watch:"
          kubectl auth can-i --as system:serviceaccount:mcp:mcp-operator watch configmaps
          echo "secrets watch:"
          kubectl auth can-i --as system:serviceaccount:mcp:mcp-operator watch secrets
      

      - name: Health check endpoints
        run: |
          set -e
          # readinessProbe/healthz по умолчанию 8081
          kubectl -n mcp port-forward deploy/mcp-operator 18081:8081 >/tmp/pf.log 2>&1 &
          PF_PID=$!
          sleep 2
          curl -fsS http://127.0.0.1:18081/healthz || (echo "healthz failed" && exit 1)
          kill $PF_PID || true

      - name: Build CLI
        run: go build -o ./bin/mcp ./cmd/mcp

      # --- Postgres in-cluster (битнами чарт) ---
      - name: Add Bitnami repo
        run: |
          helm repo add bitnami https://charts.bitnami.com/bitnami
          helm repo update

      - name: Install PostgreSQL
        run: |
          helm upgrade --install pg bitnami/postgresql \
            --namespace mcp \
            --set auth.postgresPassword=postgres \
            --set auth.database=app \
            --set primary.resources.requests.cpu=50m \
            --set primary.resources.requests.memory=128Mi
          kubectl -n mcp rollout status statefulset/pg-postgresql --timeout=300s

      - name: Compute POSTGRES_URL
        id: pgurl
        shell: bash
        run: |
          URL="postgresql://postgres:postgres@pg-postgresql.mcp.svc.cluster.local:5432/app?sslmode=disable"
          echo "URL=${URL}" >> $GITHUB_OUTPUT

      - name: Wait for CRDs (all)
        run: |
          set -e
          kubectl wait --for=condition=Established --timeout=120s crd/mcpservers.mcp.allbeone.io
          kubectl wait --for=condition=Established --timeout=120s crd/mcpserverbackups.mcp.allbeone.io
          kubectl wait --for=condition=Established --timeout=120s crd/mcpregistries.mcp.allbeone.io

          # доп.проверка, что API зарегистрирован
          kubectl api-resources --api-group=mcp.allbeone.io | grep -E 'MCPServer|MCPServerBackup|MCPRegistry'

      - name: Wait MCPRegistry synced + list servers
        run: |
          set -e
          kubectl -n mcp wait mcpregistry/default-registry \
            --for=jsonpath='{.status.conditions[?(@.type=="Synced")].status}'=True --timeout=300s || {
            echo "::error::Registry didn't sync in time"
            echo "--- conditions:"
            kubectl -n mcp get mcpregistry default-registry -o jsonpath='{.status.conditions}'; echo
            echo "--- describe:"
            kubectl -n mcp describe mcpregistry default-registry | sed -n '1,200p' || true
            echo "--- operator logs (last 200):"
            kubectl -n mcp logs deploy/mcp-operator --since=10m | tail -n 200 || true
            exit 1
          }
          echo "Discovered servers:"
          kubectl -n mcp get mcpregistry default-registry -o jsonpath='{range .status.servers[*]}{.name}{"\n"}{end}' || true

      - name: Assert CM cache for postgres exists
        run: |
          if ! kubectl -n mcp get cm mcpregistry-default-registry-postgres >/dev/null 2>&1; then
            echo "::error::Registry cache for 'postgres' not found — check registry contents or server name"
            kubectl -n mcp get cm | grep mcpregistry-default-registry || true
            exit 1
          fi

        # --- Deploy MCP Postgres server from registry ---
      - name: Deploy MCP server (postgres) from registry
        run: |
          set -e
          ./bin/mcp server deploy postgres \
            --registry default-registry \
            --kubeconfig "$KUBECONFIG" \
            --namespace mcp \
            --replicas 1 \
            --runtime docker \
            --transport stdio \
            --image mcp/postgres \
            --env POSTGRES_URL='${{ steps.pgurl.outputs.URL }}' \
            --wait --timeout 300s

      - name: Validate & dump on failure (single step)
        run: |
          set +e
          echo "== MCPServer list =="
          kubectl -n mcp get mcpservers -o wide || true
          echo "== MCPServer spec (debug) =="
          kubectl -n mcp get mcpserver postgres -o json | jq '.spec' || true
          echo "== MCPServer conditions =="
          kubectl -n mcp get mcpserver postgres -o jsonpath='{.status.conditions}' || true
          echo
          echo "== Rendered spec reference (status) =="
          kubectl -n mcp get mcpserver postgres -o jsonpath='{.status.resolvedConfigMap.name}{"\n"}{.status.resolvedHash}{"\n"}' 2>/dev/null || true
          echo
          CM_NAME="$(kubectl -n mcp get mcpserver postgres -o jsonpath='{.status.resolvedConfigMap.name}' 2>/dev/null || true)"
          if [ -n "$CM_NAME" ]; then
            echo "== Rendered ConfigMap: $CM_NAME =="
            kubectl -n mcp get cm "$CM_NAME" -o yaml || true
          else
            echo "::notice::MCPServer.status.resolvedConfigMap is empty (rendered spec not published by operator)"
          fi
          echo "== Workload (by instance label) =="
          kubectl -n mcp get deploy,po,svc -l app.kubernetes.io/instance=postgres || true
          echo "== Wait MCPServer Ready =="
          kubectl -n mcp wait mcpserver/postgres --for=condition=Ready --timeout=180s
          RC=$?
          if [ $RC -ne 0 ]; then
            echo "### Collecting diagnostics..."
            echo "=== MCPServer (full) ==="
            kubectl -n mcp get mcpserver postgres -o yaml || true

            echo "=== All resources in ns mcp ==="
            kubectl -n mcp get all -o wide || true

            echo "=== Workload by labels ==="
            kubectl -n mcp get deploy,po,svc,cm,secret -l app.kubernetes.io/instance=postgres -o yaml || true
            kubectl -n mcp get deploy,po,svc,cm,secret -l mcp.allbeone.io/name=postgres -o yaml || true

            echo "=== Operator logs (last 10m, current & previous) ==="
            OP_POD="$(kubectl -n mcp get pod -l app.kubernetes.io/name=mcp-operator -o name | head -n1 | cut -d/ -f2)"
            if [ -n "$OP_POD" ]; then
              kubectl -n mcp logs "$OP_POD" --since=10m --tail=-1 || true
              echo "--- previous:"
              kubectl -n mcp logs "$OP_POD" --since=10m --tail=-1 --previous || true
            fi

            echo "=== Recent events ==="
            kubectl -n mcp get events --sort-by=.lastTimestamp | tail -n 200 || true

            echo "=== Describe deployment/operator ==="
            kubectl -n mcp describe deploy mcp-operator || true

            echo "=== Describe workload (if present) ==="
            kubectl -n mcp describe deploy -l app.kubernetes.io/instance=postgres || true
            kubectl -n mcp describe po -l app.kubernetes.io/instance=postgres || true

            # save files for artifacts
            kubectl -n mcp get mcpserver postgres -o yaml > diag_mcpserver.yaml || true
            kubectl -n mcp get all -o yaml > diag_all.yaml || true
            [ -n "$OP_POD" ] && kubectl -n mcp logs "$OP_POD" --since=10m --tail=-1 > diag_operator_logs.txt || true
            kubectl -n mcp get events --sort-by=.lastTimestamp > diag_events.txt || true
          fi
          exit $RC

      - name: Upload diagnostics artifact
        if: ${{ failure() }}
        uses: actions/upload-artifact@v4
        with:
          name: e2e-kind-diagnostics
          path: |
            diag_mcpserver.yaml
            diag_all.yaml
            diag_operator_logs.txt
            diag_events.txt
          retention-days: 7

